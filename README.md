### Moduo网络库的相关组件介绍

| 名称                | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| EventLoop           | 反应堆模型中核心的事件分发器,包含一个poller对象和channelList |
| Poller              | 获取相关监听句柄的相关触发事件(poll和epoll)                  |
| Channel             | 处理各种I/O事件，读/写/连接/异常/断开连接                    |
| EventLoopThreadPool | 子线程池，每个线程都来处理响应的连接对象的各种事件           |
| Acceptor            | 用来接收新的用户连接，将新的连接通过回调通知给mainLoop       |
| Socket              | 相关套接字的创建，连接，断开，监听封装                       |
| Buffer              | 缓冲区，包括一个读缓冲区和一个写缓冲区                       |
| TcpConnection       | 具体处理读/写/异常操作的对象，一个channel一个connection      |

### Reactor模型

```c++
Event:注册事件和Handle
Reactor:事件集合
Demultiplex:事件分发器，触发后调用,epoll_wait
EventHandle:处理具体的事件
```

### 运转流程

```c++
1.主loop中通过acceptor对象监听连接
2.新的连接对象到了之后,通过回调的方式发送到主线程
3.主线程选择一个子线程loop对象
4.主线程创建TcpConnection对象,将其和loop对象进行绑定，其中包含了对应的channel
5.通过loop对象中的poll对象，将新的fd绑定到epoll监听中
6.事件产生后，通过各种绑定的回调，来具体的回调各种事件，读/写/异常

注意：每一个channel对象的事件，都应该抛到对应的线程中进行处理，保证数据的处理都在一个线程中，不用额外的锁开销。
```

### 比较重要的点

```c++
1.在loop线程中，执行外部的各种回调，由于当前线程没有对应的事件发生，但是此时需要调用外部的回调函数，那么需要通过wakeup来唤醒当前线程，所以创建了一个weak的事件channel，同样也绑定到poller对象上，外部通过调用weakup写一个事件来激活当前的线程，通过eventFd来创建对应的唤醒事件，通过绑定读回调，然后通过epoll对象获取到读事件信息，从而激活线程.
2.注意loop线程中执行的回调,不一定是在自己的线程中,所以一旦从外部来调用对应函数,都应该通过queueInLoop来执行,这里涉及到回调函数的不同线程的资源竞争,特意加了一把对应的锁.
3.channel对象中有个弱智能指针,用来引用外部对象,因为这个对象和channel强关联,一旦绑定,那么channel执行操作的前提条件,是这个对象一定存在,也就是这个EventLoop对象.
```

